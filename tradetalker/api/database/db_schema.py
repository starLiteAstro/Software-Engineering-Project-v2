"""Contains the database schema for the application, generated by sqlacodegen-v2."""
import datetime
from typing import Optional

from flask_login import UserMixin
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import (
    Date,
    DateTime,
    Float,
    ForeignKeyConstraint,
    Index,
    Integer,
    String,
    Text,
    text,
)
from sqlalchemy.dialects.mysql import TINYINT
from sqlalchemy.orm import Mapped, mapped_column, relationship
from werkzeug.security import generate_password_hash
import yfinance as yf

db = SQLAlchemy()


class Company(db.Model):
    """Contains the details of the companies in the database."""

    __tablename__ = "company"
    __table_args__ = (Index("stock_symbol_unique_index", "StockSymbol", unique=True),)

    CompanyID = mapped_column(Integer, primary_key=True)
    CompanyName = mapped_column(String(100, "utf8mb4_general_ci"), nullable=False)
    StockSymbol = mapped_column(String(10, "utf8mb4_general_ci"), nullable=False)
    StockPrice = mapped_column(Float, nullable=False)
    Industry = mapped_column(String(200, "utf8mb4_general_ci"), nullable=False)
    CompanyDescription = mapped_column(
        Text(collation="utf8mb4_general_ci"),
        nullable=False,
    )
    PredictedStockPrice = mapped_column(Float, nullable=False)
    StockVariance = mapped_column(Float, nullable=False)
    StockPrice_D_1 = mapped_column(Float, nullable=True)
    StockPrice_D_2 = mapped_column(Float, nullable=True)
    StockPrice_D_3 = mapped_column(Float, nullable=True)
    StockPrice_D_4 = mapped_column(Float, nullable=True)
    StockPrice_D_5 = mapped_column(Float, nullable=True)
    StockPrice_D_6 = mapped_column(Float, nullable=True)
    StockPrice_D_7 = mapped_column(Float, nullable=True)

    article: Mapped[list["Article"]] = relationship(
        "Article",
        uselist=True,
        back_populates="company",
    )
    follow: Mapped[list["Follow"]] = relationship(
        "Follow",
        uselist=True,
        back_populates="company",
    )

    def to_dict(self) -> dict:
        """ Converts a company to a dict object """
        return {
            "CompanyID": self.CompanyID,
            "CompanyName": self.CompanyName,
            "StockSymbol": self.StockSymbol,
            "StockPrice": self.StockPrice,
            "Industry": self.Industry,
            "CompanyDescription": self.CompanyDescription,
            "PredictedStockPrice": self.PredictedStockPrice,
            "StockVariance": self.StockVariance,
            "StockPrice_D_1": self.StockPrice_D_1,
            "StockPrice_D_2": self.StockPrice_D_2,
            "StockPrice_D_3": self.StockPrice_D_3,
            "StockPrice_D_4": self.StockPrice_D_4,
            "StockPrice_D_5": self.StockPrice_D_5,
            "StockPrice_D_6": self.StockPrice_D_6,
            "StockPrice_D_7": self.StockPrice_D_7
        }


class Faq(db.Model):
    """Contains the frequently asked questions and their answers."""

    __tablename__ = "faq"

    FAQID = mapped_column(Integer, primary_key=True)
    Question = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Answer = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)


class User(UserMixin, db.Model):
    """Contains the details of the users in the database."""

    __tablename__ = "user"
    __table_args__ = (
        Index("email_unique_index", "Email", unique=True),
        Index("username_unique_index", "Username", unique=True),
    )

    id = mapped_column(Integer, primary_key=True)
    Username = mapped_column(String(50, "utf8mb4_general_ci"), nullable=False)
    Password = mapped_column(String(200, "utf8mb4_general_ci"), nullable=False)
    Email = mapped_column(String(100, "utf8mb4_general_ci"), nullable=False)
    Preferences = mapped_column(Integer, nullable=False, server_default=text("'0'"))
    IsVerified = mapped_column(TINYINT(1), nullable=False, server_default=text("'0'"))
    TempToken = mapped_column(String(100, "utf8mb4_general_ci"), nullable=True)

    follow: Mapped[list["Follow"]] = relationship(
        "Follow",
        uselist=True,
        back_populates="user",
    )
    userquestion: Mapped[list["UserQuestion"]] = relationship(
        "UserQuestion",
        uselist=True,
        back_populates="user",
    )
    articlecomment: Mapped[list["ArticleComment"]] = relationship(
        "ArticleComment",
        uselist=True,
        back_populates="user",
    )
    bookmark: Mapped[list["Bookmark"]] = relationship(
        "Bookmark",
        uselist=True,
        back_populates="user",
    )
    liketable: Mapped[list["LikeTable"]] = relationship(
        "LikeTable",
        uselist=True,
        back_populates="user",
    )
    usernotificationread: Mapped[list["UserNotificationRead"]] = relationship(
        "UserNotificationRead",
        uselist=True,
        back_populates="user",
    )

    def __init__(
        self,
        username: str,
        password: str,
        email: str,
    ) -> None:
        """Initializes the user object."""
        self.Username = username
        self.Password = password
        self.Email = email

    def to_dict(self) -> dict:
        """Converts the user object to a dictionary."""
        return {
            "UserID": self.id,
            "Username": self.Username,
            "Password": self.Password,
            "Email": self.Email,
            "Preferences": self.Preferences,
            "IsVerified": self.IsVerified,
            "TempToken": self.TempToken
        }


class Article(db.Model):
    """Contains the details of the articles in the database."""

    __tablename__ = "article"
    __table_args__ = (
        ForeignKeyConstraint(
            ["CompanyID"],
            ["company.CompanyID"],
            onupdate="CASCADE",
            name="company_article_fk",
        ),
        Index("company_article_fk", "CompanyID"),
    )

    ArticleID = mapped_column(Integer, primary_key=True)
    CompanyID = mapped_column(Integer, nullable=False)
    Title = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Content = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    PublicationDate = mapped_column(Date, nullable=False)
    URL = mapped_column(String(300, "utf8mb4_general_ci"), nullable=False)
    Source = mapped_column(String(100, "utf8mb4_general_ci"), nullable=False)
    Summary = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    PredictionScore = mapped_column(Float, nullable=False)

    company: Mapped["Company"] = relationship("Company", back_populates="article")
    articlecomment: Mapped[list["ArticleComment"]] = relationship(
        "ArticleComment",
        uselist=True,
        back_populates="article",
    )
    bookmark: Mapped[list["Bookmark"]] = relationship(
        "Bookmark",
        uselist=True,
        back_populates="article",
    )
    liketable: Mapped[list["LikeTable"]] = relationship(
        "LikeTable",
        uselist=True,
        back_populates="article",
    )
    notification: Mapped[list["Notification"]] = relationship(
        "Notification",
        uselist=True,
        back_populates="article",
    )


class Follow(db.Model):
    """Contains the details of the companies that the users follow."""

    __tablename__ = "follow"
    __table_args__ = (
        ForeignKeyConstraint(
            ["CompanyID"],
            ["company.CompanyID"],
            name="company_follow_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_follow_fk"),
        Index("company_follow_fk", "CompanyID"),
        Index("user_follow_fk", "UserID"),
    )

    FollowID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    CompanyID = mapped_column(Integer, nullable=False)
    FollowDate = mapped_column(DateTime, nullable=False)

    company: Mapped["Company"] = relationship("Company", back_populates="follow")
    user: Mapped["User"] = relationship("User", back_populates="follow")


class UserQuestion(db.Model):
    """Contains the questions that the users ask."""

    __tablename__ = "userquestion"
    __table_args__ = (
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_userq_fk"),
        Index("user_userq_fk", "UserID"),
    )

    UserQuestionID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    Question = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Time = mapped_column(DateTime, nullable=False)
    IsAnswered = mapped_column(TINYINT(1), nullable=False)

    user: Mapped["User"] = relationship("User", back_populates="userquestion")


class ArticleComment(db.Model):
    """Contains the comments that the users post on the articles."""

    __tablename__ = "articlecomment"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_articlec_fk",
        ),
        ForeignKeyConstraint(
            ["ParentCommentID"],
            ["articlecomment.CommentID"],
            name="parent_articlec_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_articlec_fk"),
        Index("article_articlec_fk", "ArticleID"),
        Index("parent_articlec_fk", "ParentCommentID"),
        Index("user_articlec_fk", "UserID"),
    )

    CommentID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    ArticleID = mapped_column(Integer, nullable=False)
    Content = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Time = mapped_column(DateTime, nullable=False)
    ParentCommentID = mapped_column(Integer)

    article: Mapped["Article"] = relationship(
        "Article",
        back_populates="articlecomment",
    )
    articlecomment: Mapped[Optional["ArticleComment"]] = relationship(
        "ArticleComment",
        remote_side=[CommentID],
        back_populates="articlecomment_reverse",
    )
    articlecomment_reverse: Mapped[list["ArticleComment"]] = relationship(
        "ArticleComment",
        uselist=True,
        remote_side=[ParentCommentID],
        back_populates="articlecomment",
    )
    user: Mapped["User"] = relationship("User", back_populates="articlecomment")


class Bookmark(db.Model):
    """Contains the IDs of articles that the users bookmark."""

    __tablename__ = "bookmark"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_bookmark_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_bookmark_fk"),
        Index("article_bookmark_fk", "ArticleID"),
        Index("user_bookmark_fk", "UserID"),
    )

    BookmarkID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    ArticleID = mapped_column(Integer, nullable=False)
    BookmarkDate = mapped_column(DateTime, nullable=False)

    article: Mapped["Article"] = relationship("Article", back_populates="bookmark")
    user: Mapped["User"] = relationship("User", back_populates="bookmark")


class LikeTable(db.Model):
    """Contains the IDs of articles that the users like."""

    __tablename__ = "liketable"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_like_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_like_fk"),
        Index("article_like_fk", "ArticleID"),
        Index("user_like_fk", "UserID"),
    )

    LikeID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    ArticleID = mapped_column(Integer, nullable=False)
    LikeDate = mapped_column(DateTime, nullable=False)

    article: Mapped["Article"] = relationship("Article", back_populates="liketable")
    user: Mapped["User"] = relationship("User", back_populates="liketable")


class Notification(db.Model):
    """Contains the notifications that the users receive."""

    __tablename__ = "notification"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_notification_fk",
        ),
        Index("article_notification_fk", "ArticleID"),
    )

    NotificationID = mapped_column(Integer, primary_key=True)
    ArticleID = mapped_column(Integer, nullable=False)
    Content = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Time = mapped_column(DateTime, nullable=False)

    article: Mapped["Article"] = relationship("Article", back_populates="notification")
    usernotificationread: Mapped[list["UserNotificationRead"]] = relationship(
        "UserNotificationRead",
        uselist=True,
        back_populates="notification",
    )


class UserNotificationRead(db.Model):
    """Contains the IDs of notifications that the users have read."""

    __tablename__ = "usernotificationread"
    __table_args__ = (
        ForeignKeyConstraint(
            ["NotificationID"],
            ["notification.NotificationID"],
            name="notification_unr_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_unr_fk"),
        Index("notification_unr_fk", "NotificationID"),
        Index("user_unr_fk", "UserID"),
    )

    UserNotificationReadID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    NotificationID = mapped_column(Integer, nullable=False)
    IsRead = mapped_column(TINYINT(1), nullable=False, server_default=text("'0'"))

    notification: Mapped["Notification"] = relationship(
        "Notification",
        back_populates="usernotificationread",
    )
    user: Mapped["User"] = relationship("User", back_populates="usernotificationread")


def add_data() -> None:
    """Adds initial data to the database."""
    user_list = [
        User(
            "User1",
            generate_password_hash("Password123!"),
            "user@gmail.com",
        ),
        User(
            "User2",
            generate_password_hash("Password1234!"),
            "user2@gmail.com",
        ),
    ]
    db.session.add_all(user_list)
    db.session.commit()


def add_base_company_data() -> None:
    """ Adds initial data of the FTSE100 companies to the database """
    symbols = ['III.L', 'ADM.L', 'AAF.L', 'AAL.L', 'ANTO.L', 'AHT.L', 'ABF.L', 'AZN.L', 'AUTO.L', 'AV.L', 'BME.L',
               'BA.L', 'BARC.L', 'BDEV.L', 'BEZ.L', 'BKG.L', 'BP.L', 'BATS.L', 'BT-A.L', 'BNZL.L', 'BRBY.L', 'CNA.L',
               'CCH.L', 'CPG.L', 'CTEC.L', 'CRDA.L', 'DCC.L', 'DGE.L', 'DPLM.L', 'EDV.L', 'ENT.L', 'EXPN.L', 'FCIT.L',
               'FLTR.L', 'FRAS.L', 'FRES.L', 'GLEN.L', 'GSK.L', 'HLN.L', 'HLMA.L', 'HIK.L', 'HWDN.L', 'HSBA.L', 'IHG.L',
               'IMI.L', 'IMB.L', 'INF.L', 'ICP.L', 'IAG.L', 'ITRK.L', 'JD.L', 'KGF.L', 'LAND.L', 'LGEN.L', 'LLOY.L',
               'LSEG.L', 'MNG.L', 'MKS.L', 'MRO.L', 'MNDI.L', 'NG.L', 'NWG.L', 'NXT.L', 'OCDO.L', 'PSON.L', 'PSH.L',
               'PSN.L', 'PHNX.L', 'PRU.L', 'RKT.L', 'REL.L', 'RTO.L', 'RMV.L', 'RIO.L', 'RR.L', 'RS1.L', 'SGE.L',
               'SBRY.L', 'SDR.L', 'SMT.L', 'SGRO.L', 'SVT.L', 'SHEL.L', 'SMDS.L', 'SMIN.L', 'SN.L', 'SKG.L', 'SPX.L',
               'SSE.L', 'STAN.L', 'STJ.L', 'TW.L', 'TSCO.L', 'ULVR.L', 'UU.L', 'UTG.L', 'VOD.L', 'WEIR.L', 'WTB.L',
               'WPP.L']
    companies = []
    for symbol in symbols:
        company = yf.Ticker(symbol)
        past_8_days_price = company.history(period='8d')['Close'].tolist()
        companies.append(Company(
            company.info.get('longName', 'N/A'),  # CompanyName
            symbol,     # StockSymbol
            past_8_days_price[0],  # StockPrice
            company.info.get('industry', 'N/A'),  # Industry
            company.info.get('longBusinessSummary', 'N/A'),  # CompanyDescription
            None,  # PredictedStockPrice
            None,  # StockVariance
            past_8_days_price[1],  # StockPrice_D_1
            past_8_days_price[2],  # StockPrice_D_2
            past_8_days_price[3],  # StockPrice_D_3
            past_8_days_price[4],  # StockPrice_D_4
            past_8_days_price[5],  # StockPrice_D_5
            past_8_days_price[6],  # StockPrice_D_6
            past_8_days_price[7]   # StockPrice_D_7
        ))

        db.session.add_all(companies)
        db.session.commit()

def company_daily_update(company: Company) -> None:
    """ Performs the daily update of the companies """
    try:
        ticker = yf.Ticker(company.StockSymbol)
        history = ticker.history(period='1d')
        if history.empty:
            # Handle the case where no data is returned
            print(f"No data returned for {company.StockSymbol}")
            return

        # Update stock price history
        company.StockPrice_D_7 = company.StockPrice_D_6
        company.StockPrice_D_6 = company.StockPrice_D_5
        company.StockPrice_D_5 = company.StockPrice_D_4
        company.StockPrice_D_4 = company.StockPrice_D_3
        company.StockPrice_D_3 = company.StockPrice_D_2
        company.StockPrice_D_2 = company.StockPrice_D_1
        company.StockPrice_D_1 = company.StockPrice
        company.StockPrice = history['Close'][-1]

        # ----- This is the part where we apply the prediction formula and calculate stock_variance and predicted_price
        # sentiment scores of the related articles for each company on the day
        sentiment_scores = []
        articles = Article.query.filter_by(
            CompanyID=company.CompanyID
        ).filter_by(
            PublicationDate=datetime.date.today()
        ).all()  # check if the date format is the same as publication_date
        for article in articles:
            sentiment_scores.append(article.PredictionScore)

        # variance calculations here
        # stock_variance = ... , uncomment when done
        company.StockVariance = None  # change to stock_variance
        # prediction calculations here
        # predicted_stock_price = ... , uncomment when done
        company.PredictedStockPrice = None  # change to predicted_stock_price

        # Commit changes to the database
        db.session.add(company)
        db.session.commit()
        print(f"Stock price updated for {company.StockSymbol}")
    except Exception as e:
        # Handle any errors that occur during the update process
        print(f"Error updating stock price for {company.StockSymbol}: {str(e)}")
        db.session.rollback()  # Rollback changes in case of an error


def update_all_companies_daily() -> bool:
    """Updates daily stock prices for all companies."""
    try:
        companies = Company.query.all()
        for company in companies:
            company_daily_update(company)
        print("Daily updates for all companies completed successfully.")
        return True
    except Exception as e:
        print("Error updating daily stock prices:", str(e))
        db.session.rollback()  # Rollback changes in case of an error
        return False
