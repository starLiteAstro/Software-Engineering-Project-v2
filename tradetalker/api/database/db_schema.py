"""Contains the database schema for the application, generated by sqlacodegen-v2."""

import logging
from datetime import UTC, datetime, timedelta
from typing import Optional

import jwt
import yfinance as yf
from flask_login import UserMixin
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import (
    DateTime,
    Float,
    ForeignKeyConstraint,
    Index,
    Integer,
    String,
    Text,
    text,
    update,
)
from sqlalchemy.dialects.mysql import TINYINT
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from sqlalchemy.orm import (  # type: ignore [attr-defined]
    Mapped,
    mapped_column,
    relationship,
)
from werkzeug.security import generate_password_hash

from . import extract_news_script
from .linear_regression.linear_regression import TTLinearRegression

db = SQLAlchemy()

HIGHLY_POSITIVE_SCORE = 0.95
HIGHLY_NEGATIVE_SCORE = -0.95


class Company(db.Model):  # type: ignore [name-defined]
    """Contains the details of the companies in the database."""

    __tablename__ = "company"
    __table_args__ = (Index("stock_symbol_unique_index", "StockSymbol", unique=True),)

    CompanyID = mapped_column(Integer, primary_key=True)
    CompanyName = mapped_column(String(100, "utf8mb4_general_ci"), nullable=False)
    StockSymbol = mapped_column(String(10, "utf8mb4_general_ci"), nullable=False)
    StockPrice = mapped_column(Float, nullable=False)
    Industry = mapped_column(String(200, "utf8mb4_general_ci"), nullable=False)
    CompanyDescription = mapped_column(
        Text(collation="utf8mb4_general_ci"),
        nullable=False,
    )
    PredictedStockPrice = mapped_column(Float, nullable=True)
    StockVariance = mapped_column(Float, nullable=True)
    StockPrice_D_1 = mapped_column(Float, nullable=True)
    StockPrice_D_2 = mapped_column(Float, nullable=True)
    StockPrice_D_3 = mapped_column(Float, nullable=True)
    StockPrice_D_4 = mapped_column(Float, nullable=True)
    StockPrice_D_5 = mapped_column(Float, nullable=True)
    StockPrice_D_6 = mapped_column(Float, nullable=True)
    StockPrice_D_7 = mapped_column(Float, nullable=True)

    article: Mapped[list["Article"]] = relationship(
        "Article",
        uselist=True,
        back_populates="company",
    )
    follow: Mapped[list["Follow"]] = relationship(
        "Follow",
        uselist=True,
        back_populates="company",
    )

    def __init__(
        self,
        company_name: str,
        stock_symbol: str,
        stock_price: float,
        industry: str,
        company_description: str,
        predicted_stock_price: float | None,
        stock_variance: float | None,
        stock_price_d_1: float | None,
        stock_price_d_2: float | None,
        stock_price_d_3: float | None,
        stock_price_d_4: float | None,
        stock_price_d_5: float | None,
        stock_price_d_6: float | None,
        stock_price_d_7: float | None,
    ) -> None:
        """Initializes the company object."""
        self.CompanyName = company_name
        self.StockSymbol = stock_symbol
        self.StockPrice = stock_price
        self.Industry = industry
        self.CompanyDescription = company_description
        self.PredictedStockPrice = predicted_stock_price
        self.StockVariance = stock_variance
        self.StockPrice_D_1 = stock_price_d_1
        self.StockPrice_D_2 = stock_price_d_2
        self.StockPrice_D_3 = stock_price_d_3
        self.StockPrice_D_4 = stock_price_d_4
        self.StockPrice_D_5 = stock_price_d_5
        self.StockPrice_D_6 = stock_price_d_6
        self.StockPrice_D_7 = stock_price_d_7

    def to_dict(self) -> dict:
        """Converts a company to a dict object."""
        return {
            "id": self.CompanyID,
            "name": self.CompanyName,
            "symbol": self.StockSymbol,
            "stock_price": self.StockPrice,
            "industry": self.Industry,
            "description": self.CompanyDescription,
            "predicted_stock_price": self.PredictedStockPrice,
            "stock_variance": self.StockVariance,
            "stock_d1": self.StockPrice_D_1,
            "stock_d2": self.StockPrice_D_2,
            "stock_d3": self.StockPrice_D_3,
            "stock_d4": self.StockPrice_D_4,
            "stock_d5": self.StockPrice_D_5,
            "stock_d6": self.StockPrice_D_6,
            "stock_d7": self.StockPrice_D_7,
            "rank": self.get_company_stock_rank(),
        }

    def select_company_by_id(self) -> dict | None:
        """Selects a company by its ID."""
        try:
            company = (
                db.session.execute(
                    db.select(Company)
                    .filter(Company.CompanyID == self.CompanyID)
                    .first(),
                )
                .scalars()
                .all()
            )
        except SQLAlchemyError:
            logging.exception("Found an error while selecting the company by ID.")
            return None
        else:
            return company  # type: ignore [union-attr]

    def select_company_by_name(self) -> str | None:
        """Selects a company by its name."""
        try:
            company = (
                db.session.execute(
                    db.select(Company)
                    .filter(Company.CompanyName == self.CompanyName)
                    .first(),
                )
                .scalars()
                .all()
            )
        except SQLAlchemyError:
            logging.exception("Found an error while selecting the company by name.")
            return None
        else:
            return company

    def get_company_stock_rank(self) -> int:
        """Gets the rank of a company based on its stock price."""
        try:
            rank = db.session.execute(
                db.select(db.func.count())
                .select_from(Company)
                .filter(Company.StockPrice > self.StockPrice),
            ).scalar()
            return rank + 1
        except SQLAlchemyError:
            logging.exception("Found an error while getting the company stock rank.")
            return 0


class Faq(db.Model):  # type: ignore [name-defined]
    """Contains the frequently asked questions and their answers."""

    __tablename__ = "faq"

    FAQID = mapped_column(Integer, primary_key=True)
    Question = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Answer = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)

    def __init__(self, question: str, answer: str) -> None:
        """Initializes the FAQ object."""
        self.Question = question
        self.Answer = answer


class User(UserMixin, db.Model):  # type: ignore [name-defined]
    """Contains the details of the users in the database."""

    __tablename__ = "user"
    __table_args__ = (
        Index("email_unique_index", "Email", unique=True),
        Index("username_unique_index", "Username", unique=True),
    )

    id = mapped_column(Integer, primary_key=True)
    Username = mapped_column(String(50, "utf8mb4_general_ci"), nullable=False)
    Password = mapped_column(String(200, "utf8mb4_general_ci"), nullable=False)
    Email = mapped_column(String(100, "utf8mb4_general_ci"), nullable=False)
    IsVerified = mapped_column(TINYINT(1), nullable=False, server_default=text("'0'"))

    follow: Mapped[list["Follow"]] = relationship(
        "Follow",
        uselist=True,
        back_populates="user",
    )
    userquestion: Mapped[list["UserQuestion"]] = relationship(
        "UserQuestion",
        uselist=True,
        back_populates="user",
    )
    articlecomment: Mapped[list["ArticleComment"]] = relationship(
        "ArticleComment",
        uselist=True,
        cascade="all, delete",
        back_populates="user",
    )
    bookmark: Mapped[list["Bookmark"]] = relationship(
        "Bookmark",
        uselist=True,
        back_populates="user",
    )
    liketable: Mapped[list["LikeTable"]] = relationship(
        "LikeTable",
        uselist=True,
        back_populates="user",
    )
    usernotificationread: Mapped[list["UserNotificationRead"]] = relationship(
        "UserNotificationRead",
        uselist=True,
        cascade="all, delete",
        back_populates="user",
    )

    def __init__(
        self,
        username: str,
        password: str,
        email: str,
    ) -> None:
        """Initializes the user object."""
        self.Username = username
        self.Password = password
        self.Email = email

    def to_dict(self) -> dict:
        """Converts the user object to a dictionary."""
        return {
            "UserID": self.id,
            "Username": self.Username,
            "Password": self.Password,
            "Email": self.Email,
            "IsVerified": self.IsVerified,
        }

    def get_reset_token(self, expires_sec: int = 1800) -> str:
        """Generates a token for resetting the password."""
        return jwt.encode(
            {
                "user_id": self.id,
                "exp": datetime.now(UTC) + timedelta(seconds=expires_sec),
            },
            "secret_key",
            algorithm="HS256",
        )

    @staticmethod
    def verify_reset_token(token: str) -> int | None:
        """Verifies the token for resetting the password."""
        try:
            user_id = jwt.decode(token, "secret_key", algorithms=["HS256"])["user_id"]
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
        return user_id


class Article(db.Model):  # type: ignore [name-defined]
    """Contains the details of the articles in the database."""

    __tablename__ = "article"
    __table_args__ = (
        ForeignKeyConstraint(
            ["CompanyID"],
            ["company.CompanyID"],
            onupdate="CASCADE",
            name="company_article_fk",
        ),
        Index("company_article_fk", "CompanyID"),
    )

    ArticleID = mapped_column(Integer, primary_key=True)
    CompanyID = mapped_column(Integer, nullable=False)
    Title = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Content = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    PublicationDate = mapped_column(DateTime, nullable=False)
    URL = mapped_column(String(300, "utf8mb4_general_ci"), nullable=False)
    Summary = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    PredictionScore = mapped_column(Float, nullable=False)
    KeyWords = mapped_column(String(100, "utf8mb4_general_ci"), nullable=True)
    ProcessedArticle = mapped_column(
        Text(collation="utf8mb4_general_ci"),
        nullable=True,
    )

    company: Mapped["Company"] = relationship("Company", back_populates="article")
    articlecomment: Mapped[list["ArticleComment"]] = relationship(
        "ArticleComment",
        uselist=True,
        back_populates="article",
    )
    bookmark: Mapped[list["Bookmark"]] = relationship(
        "Bookmark",
        uselist=True,
        back_populates="article",
    )
    liketable: Mapped[list["LikeTable"]] = relationship(
        "LikeTable",
        uselist=True,
        back_populates="article",
    )
    notification: Mapped[list["Notification"]] = relationship(
        "Notification",
        uselist=True,
        back_populates="article",
    )

    def __init__(
        self,
        company_id: int,
        title: str,
        content: str,
        publication_date: datetime,
        url: str,
        summary: str,
        prediction_score: float,
        processed_article: str | None,
    ) -> None:
        """Initializes the article object."""
        self.CompanyID = company_id
        self.Title = title
        self.Content = content
        self.PublicationDate = publication_date
        self.URL = url
        self.Summary = summary
        self.PredictionScore = prediction_score
        self.ProcessedArticle = processed_article


"""Not working at the moment.
@event.listens_for(Article, "after_insert")
def receive_after_insert(mapper, connection, target) -> None:
    ""Sends a notification to the users when a new article linked to a company that they follow is posted.""
    try:
        print("New article added", flush=True)
        company_id = target.CompanyID
        user_ids = connection.execute(
            db.select(Follow.UserID).where(Follow.CompanyID == company_id)
        )
        notification = Notification(target.ArticleID, f"New article: {target.Title}")
        connection.add(notification)
        connection.commit()
        for user_id in user_ids:
            usernotificationread = UserNotificationRead(user_id, notification.NotificationID)
            connection.add(usernotificationread)
            connection.commit()
    except SQLAlchemyError as e:
        logging.exception(e)
        connection.rollback()
"""


class Follow(db.Model):  # type: ignore [name-defined]
    """Contains the details of the companies that the users follow."""

    __tablename__ = "follow"
    __table_args__ = (
        ForeignKeyConstraint(
            ["CompanyID"],
            ["company.CompanyID"],
            name="company_follow_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_follow_fk"),
        Index("company_follow_fk", "CompanyID"),
        Index("user_follow_fk", "UserID"),
    )

    FollowID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    CompanyID = mapped_column(Integer, nullable=False)
    FollowDate = mapped_column(DateTime, nullable=False)

    company: Mapped["Company"] = relationship("Company", back_populates="follow")
    user: Mapped["User"] = relationship("User", back_populates="follow")

    def __init__(self, user_id: int, company_id: int) -> None:
        """Initializes the follow object."""
        self.UserID = user_id
        self.CompanyID = company_id
        self.FollowDate = datetime.now(UTC)


class UserQuestion(db.Model):  # type: ignore [name-defined]
    """Contains the questions that the users ask."""

    __tablename__ = "userquestion"
    __table_args__ = (
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_userq_fk"),
        Index("user_userq_fk", "UserID"),
    )

    UserQuestionID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    Question = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Time = mapped_column(DateTime, nullable=False)
    IsAnswered = mapped_column(TINYINT(1), nullable=False)

    user: Mapped["User"] = relationship("User", back_populates="userquestion")

    def __init__(self, user_id: int, question: str) -> None:
        """Initializes the userquestion object."""
        self.UserID = user_id
        self.Question = question
        self.Time = datetime.now(UTC)
        self.IsAnswered = 0


class ArticleComment(db.Model):  # type: ignore [name-defined]
    """Contains the comments that the users post on the articles."""

    __tablename__ = "articlecomment"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_articlec_fk",
        ),
        ForeignKeyConstraint(
            ["ParentCommentID"],
            ["articlecomment.CommentID"],
            ondelete="CASCADE",
            name="parent_articlec_fk",
        ),
        ForeignKeyConstraint(
            ["UserID"],
            ["user.id"],
            ondelete="CASCADE",
            name="user_articlec_fk",
        ),
        Index("article_articlec_fk", "ArticleID"),
        Index("parent_articlec_fk", "ParentCommentID"),
        Index("user_articlec_fk", "UserID"),
    )

    CommentID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    ArticleID = mapped_column(Integer, nullable=False)
    Content = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Time = mapped_column(DateTime, nullable=False)
    ParentCommentID = mapped_column(Integer)

    article: Mapped["Article"] = relationship(
        "Article",
        back_populates="articlecomment",
    )
    articlecomment: Mapped[Optional["ArticleComment"]] = relationship(
        "ArticleComment",
        remote_side=[CommentID],
        back_populates="articlecomment_reverse",
    )
    articlecomment_reverse: Mapped[list["ArticleComment"]] = relationship(
        "ArticleComment",
        uselist=True,
        remote_side=[ParentCommentID],
        back_populates="articlecomment",
    )
    user: Mapped["User"] = relationship(
        "User",
        back_populates="articlecomment",
        cascade="all, delete",
    )

    def __init__(
        self,
        user_id: int,
        article_id: int,
        content: str,
        parent_comment_id: int | None,
    ) -> None:
        """Initializes the articlecomment object."""
        self.UserID = user_id
        self.ArticleID = article_id
        self.Content = content
        self.Time = datetime.now(UTC)
        self.ParentCommentID = parent_comment_id


class Bookmark(db.Model):  # type: ignore [name-defined]
    """Contains the IDs of articles that the users bookmark."""

    __tablename__ = "bookmark"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_bookmark_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_bookmark_fk"),
        Index("article_bookmark_fk", "ArticleID"),
        Index("user_bookmark_fk", "UserID"),
    )

    BookmarkID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    ArticleID = mapped_column(Integer, nullable=False)
    BookmarkDate = mapped_column(DateTime, nullable=False)

    article: Mapped["Article"] = relationship("Article", back_populates="bookmark")
    user: Mapped["User"] = relationship("User", back_populates="bookmark")

    def __init__(self, user_id: int, article_id: int) -> None:
        """Initializes the bookmark object."""
        self.UserID = user_id
        self.ArticleID = article_id
        self.BookmarkDate = datetime.now(UTC)


class LikeTable(db.Model):  # type: ignore [name-defined]
    """Contains the IDs of articles that the users like."""

    __tablename__ = "liketable"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_like_fk",
        ),
        ForeignKeyConstraint(["UserID"], ["user.id"], name="user_like_fk"),
        Index("article_like_fk", "ArticleID"),
        Index("user_like_fk", "UserID"),
    )

    LikeID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    ArticleID = mapped_column(Integer, nullable=False)
    LikeDate = mapped_column(DateTime, nullable=False)

    article: Mapped["Article"] = relationship("Article", back_populates="liketable")
    user: Mapped["User"] = relationship("User", back_populates="liketable")

    def __init__(self, user_id: int, article_id: int) -> None:
        """Initializes the liketable object."""
        self.UserID = user_id
        self.ArticleID = article_id
        self.LikeDate = datetime.now(UTC)

    def get_liked_articles_keywords(self, user_id: int) -> list[str] | None:
        """Gets the keywords of the articles that the user has liked."""
        try:
            liked_articles = (
                db.session.query(LikeTable)
                .filter(LikeTable.UserID == user_id)
                .join(Article, LikeTable.ArticleID == Article.ArticleID)
                .with_entities(Article.KeyWords)
                .all()
            )
            return [article.KeyWords for article in liked_articles]
        except SQLAlchemyError:
            logging.exception("Found an error while getting the liked articles.")
            return None


class Notification(db.Model):  # type: ignore [name-defined]
    """Contains the notifications that the users receive."""

    __tablename__ = "notification"
    __table_args__ = (
        ForeignKeyConstraint(
            ["ArticleID"],
            ["article.ArticleID"],
            name="article_notification_fk",
        ),
        Index("article_notification_fk", "ArticleID"),
    )

    NotificationID = mapped_column(Integer, primary_key=True)
    ArticleID = mapped_column(Integer, nullable=True)
    Content = mapped_column(Text(collation="utf8mb4_general_ci"), nullable=False)
    Time = mapped_column(DateTime, nullable=False)

    article: Mapped["Article"] = relationship("Article", back_populates="notification")
    usernotificationread: Mapped[list["UserNotificationRead"]] = relationship(
        "UserNotificationRead",
        uselist=True,
        back_populates="notification",
    )

    def __init__(self, article_id: int | None, content: str) -> None:
        """Initializes the notification object."""
        self.ArticleID = article_id
        self.Content = content
        self.Time = datetime.now(UTC)


class UserNotificationRead(db.Model):  # type: ignore [name-defined]
    """Contains the IDs of notifications that the users have read."""

    __tablename__ = "usernotificationread"
    __table_args__ = (
        ForeignKeyConstraint(
            ["NotificationID"],
            ["notification.NotificationID"],
            name="notification_unr_fk",
        ),
        ForeignKeyConstraint(
            ["UserID"],
            ["user.id"],
            ondelete="CASCADE",
            name="user_unr_fk",
        ),
        Index("notification_unr_fk", "NotificationID"),
        Index("user_unr_fk", "UserID"),
    )

    UserNotificationReadID = mapped_column(Integer, primary_key=True)
    UserID = mapped_column(Integer, nullable=False)
    NotificationID = mapped_column(Integer, nullable=False)
    IsRead = mapped_column(TINYINT(1), nullable=False, server_default=text("'0'"))

    notification: Mapped["Notification"] = relationship(
        "Notification",
        back_populates="usernotificationread",
    )
    user: Mapped["User"] = relationship("User", back_populates="usernotificationread")

    def __init__(self, user_id: int, notification_id: int) -> None:
        """Initializes the usernotificationread object."""
        self.UserID = user_id
        self.NotificationID = notification_id
        self.IsRead = 0


def add_data() -> None:
    """Adds initial data to the database."""
    user_list = [
        User(
            "User1",
            generate_password_hash("Password123!"),
            "user@gmail.com",
        ),
        User(
            "User2",
            generate_password_hash("Password1234!"),
            "user2@gmail.com",
        ),
    ]
    article_list = [
        # This article should not show up in the weekly feed
        Article(
            1,
            "Google investing $1bn in UK data centre",
            "Google has invested $1bn (£790m) to build its first UK data centre. The construction had started at a 33-acre site in Waltham Cross, Hertfordshire, and hoped it would be completed by 2025. Google stressed it was too early to say how many jobs would be created, but said it would be in the thousands.",
            datetime.now(UTC) - timedelta(days=8),
            "https://www.bbc.co.uk/",
            "Google has invested $1bn (£790m) to build its first UK data centre. The construction had started at a 33-acre site in Waltham Cross, Hertfordshire, and hoped it would be completed by 2025. Google stressed it was too early to say how many jobs would be created, but said it would be in the thousands.",
            0.8,
            "google invest uk data centre construction job thousands site waltham cross hertfordshire 2025 first thousands",
        ),
    ]
    faq_list = [
        Faq(
            "What is TradeTalk?",
            "TradeTalk is a platform that provides users with the latest news and information about the stock market and companies. It also allows users to follow companies and receive notifications about them.",
        ),
        Faq(
            "How do I post comments?",
            "To post a comment, you must be verified. Once you are verified, you can post a comment on any article.",
        ),
        Faq(
            "How do I follow a company?",
            "To follow a company, simply search for the company using the search bar and click on the 'Follow' button on the company's page. You will then receive notifications about the company's news and updates.",
        ),
        Faq(
            "How do I get notifications?",
            "You will receive notifications about the companies you follow when new articles are posted about them. You can also receive notifications about your questions being answered.",
        ),
    ]
    notification_list = [
        Notification(
            1,
            "New article: The headline of Article 1",
        ),
        Notification(
            1,
            "New article: The headline of Article 2",
        ),
    ]
    user_notification_read_list = [
        UserNotificationRead(
            1,
            1,
        ),
        UserNotificationRead(
            2,
            2,
        ),
    ]
    article_comment_list = [
        ArticleComment(
            1,
            1,
            "This is a great comment.",
            None,
        ),
        ArticleComment(
            2,
            1,
            "This is another great comment.",
            1,
        ),
        ArticleComment(
            1,
            1,
            "This is a comment.",
            None,
        ),
    ]
    db.session.add_all(user_list)
    db.session.add_all(article_list)
    db.session.add_all(faq_list)
    db.session.add_all(notification_list)
    db.session.add_all(user_notification_read_list)
    db.session.add_all(article_comment_list)
    db.session.commit()


def add_base_company_data() -> None:
    """Adds initial data of the FTSE100 companies to the database."""
    symbols = [
        "III.L",
        "ADM.L",
        "AAF.L",
        "AAL.L",
        "ANTO.L",
        "AHT.L",
        "ABF.L",
        "AZN.L",
        "AUTO.L",
        "AV.L",
        "BME.L",
        "BA.L",
        "BARC.L",
        "BDEV.L",
        "BEZ.L",
        "BKG.L",
        "BP.L",
        "BATS.L",
        "BT-A.L",
        "BNZL.L",
        "BRBY.L",
        "CNA.L",
        "CCH.L",
        "CPG.L",
        "CTEC.L",
        "CRDA.L",
        "DCC.L",
        "DGE.L",
        "DPLM.L",
        "EDV.L",
        "ENT.L",
        "EXPN.L",
        "FCIT.L",
        "FLTR.L",
        "FRAS.L",
        "FRES.L",
        "GLEN.L",
        "GSK.L",
        "HLN.L",
        "HLMA.L",
        "HIK.L",
        "HWDN.L",
        "HSBA.L",
        "IHG.L",
        "IMI.L",
        "IMB.L",
        "INF.L",
        "ICP.L",
        "IAG.L",
        "ITRK.L",
        "JD.L",
        "KGF.L",
        "LAND.L",
        "LGEN.L",
        "LLOY.L",
        "LSEG.L",
        "MNG.L",
        "MKS.L",
        "MRO.L",
        "MNDI.L",
        "NG.L",
        "NWG.L",
        "NXT.L",
        "OCDO.L",
        "PSON.L",
        "PSH.L",
        "PSN.L",
        "PHNX.L",
        "PRU.L",
        "RKT.L",
        "REL.L",
        "RTO.L",
        "RMV.L",
        "RIO.L",
        "RR.L",
        "RS1.L",
        "SGE.L",
        "SBRY.L",
        "SDR.L",
        "SMT.L",
        "SGRO.L",
        "SVT.L",
        "SHEL.L",
        "SMDS.L",
        "SMIN.L",
        "SN.L",
        "SKG.L",
        "SPX.L",
        "SSE.L",
        "STAN.L",
        "STJ.L",
        "TW.L",
        "TSCO.L",
        "ULVR.L",
        "UU.L",
        "UTG.L",
        "VOD.L",
        "WEIR.L",
        "WTB.L",
        "WPP.L",
    ]
    companies = []
    for symbol in symbols:
        company = yf.Ticker(symbol)
        past_8_days_price = company.history(period="8d")["Close"].tolist()
        companies.append(
            Company(
                company.info.get("longName", "N/A"),  # CompanyName
                symbol,  # StockSymbol
                past_8_days_price[7],  # StockPrice
                company.info.get("industry", "N/A"),  # Industry
                company.info.get("longBusinessSummary", "N/A"),  # CompanyDescription
                None,  # PredictedStockPrice
                None,  # StockVariance
                past_8_days_price[6],  # StockPrice_D_1
                past_8_days_price[5],  # StockPrice_D_2
                past_8_days_price[4],  # StockPrice_D_3
                past_8_days_price[3],  # StockPrice_D_4
                past_8_days_price[2],  # StockPrice_D_5
                past_8_days_price[1],  # StockPrice_D_6
                past_8_days_price[0],  # StockPrice_D_7
            ),
        )

        db.session.add_all(companies)
        db.session.commit()


def company_daily_update(company: Company) -> None:
    """Performs the daily update of the companies."""
    try:
        ticker = yf.Ticker(company.StockSymbol)
        history = ticker.history(period="1d")
        if history.empty:
            # Handle the case where no data is returned
            logging.info("No data returned for %s", company.StockSymbol)
            return

        # Update stock price history
        # company.StockPrice_D_7 = company.StockPrice_D_6
        # company.StockPrice_D_6 = company.StockPrice_D_5
        # company.StockPrice_D_5 = company.StockPrice_D_4
        # company.StockPrice_D_4 = company.StockPrice_D_3
        # company.StockPrice_D_3 = company.StockPrice_D_2
        # company.StockPrice_D_2 = company.StockPrice_D_1
        # company.StockPrice_D_1 = company.StockPrice
        # company.StockPrice = history["Close"][-1]

        # ----- This is the part where we apply the prediction formula and calculate stock_variance and predicted_price
        # sentiment scores of the related articles for each company on the day
        articles = (
            Article.query.filter_by(CompanyID=company.CompanyID)
            .filter_by(PublicationDate=datetime.now(UTC))
            .all()
        )  # Check if the date format is the same as publication_date
        _sentiment_scores = [article.PredictionScore for article in articles]

        # variance calculations here
        # stock_variance = ... , uncomment when done
        company.StockVariance = None  # change to stock_variance
        # prediction calculations here
        # predicted_stock_price = ... , uncomment when done
        company.PredictedStockPrice = None  # change to predicted_stock_price

        # Commit changes to the database
        db.session.add(company)
        db.session.commit()
        logging.info("Stock price updated for %s", company.StockSymbol)
    except IntegrityError:
        # errors
        logging.exception(
            "Error updating stock price for %s",
            company.StockSymbol,
        )
        db.session.rollback()  # Rollback changes in case of an error


def get_company_article_sentiment_scores(company_id: int) -> list:
    """Returns all the sentiment scores of the articles related to a company within the last n days."""
    articles = (
        db.session.execute(db.select(Article).filter_by(CompanyID=company_id))
        .scalars()
        .all()
    )

    sentiment_scores = []
    for article in articles:
        sentiment_scores.append(article.PredictionScore)

    if not sentiment_scores:
        sentiment_scores = [0, 0]
    return sentiment_scores


def get_articles_by_company_name(company_name: str) -> list:
    """Returns all articles related to a company, for keyword analysis."""
    company = (
        db.session.execute(
            db.select(Company).filter(Company.CompanyName.like(f"%{company_name}%")),
        )
        .scalars()
        .first()
    )
    if not company:
        print("No result found for company named: ", company_name)
        return []

    articles = (
        db.session.execute(db.select(Article).filter_by(CompanyID=company.CompanyID))
        .scalars()
        .all()
    )
    if not articles:
        print("No articles found for the company ", company_name)
    return articles


def set_article_keywords(article_keywords_pairs: list[dict]) -> None:
    """Updates the keywords of articles in the database based on the provided pairs of article IDs and corresponding keywords.

    Parameters
    ----------
    article_keywords_pairs : list[dict]
        List of dictionaries containing article ID as the key and keywords as the value.

    Raises
    ------
        Any errors encountered during the execution will be propagated.

    """
    for article_keywords_pair in article_keywords_pairs:
        try:
            # Fixing the syntax errors
            db.session.execute(
                update(Article)
                .where(Article.ArticleID == article_keywords_pair.keys())
                .values(KeyWords=article_keywords_pair.values()),
            )
            db.session.commit()
        except IntegrityError as e:
            # Handle exceptions appropriately
            print(
                f"An error occurred in the member at article id {article_keywords_pair.keys()}: {e}",
            )


def get_article_from_news_script(article: dict) -> int | None:
    """Inserts the article recieved from the news script into the database."""
    # need the company_id first
    company = (
        db.session.execute(
            db.select(Company).filter(
                Company.CompanyName.like(f'%{article["Company"]}%'),
            ),
        )
        .scalars()
        .first()
    )
    if not company:
        print("Couldn't find the company name in the table for ", article["Company"])
        return None
    print(company.CompanyID)

    new_article = Article(
        company_id=company.CompanyID,
        title=article["Title"],
        publication_date=article["PublicationDate"],
        url=article["URL"],
        summary=article["Summary"],
        prediction_score=article["PredictionScore"],
        content=article["Content"],
        processed_article=article["ProcessedArticle"],
    )
    db.session.add(new_article)
    db.session.commit()
    return new_article.ArticleID


def get_all_company_names() -> list:
    """Returns the name of all articles."""
    companies = db.session.execute(db.select(Company)).scalars().all()
    company_names = [company.CompanyName for company in companies]
    print(company_names)
    return company_names


def get_company_data_for_linear_regression(company: Company) -> dict:
    """Returns the data needed for our linear regression model in the form of a dict."""
    company_data = {"StockSymbol": company.StockSymbol}
    price_historic = [
        company.StockPrice_D_1,
        company.StockPrice_D_2,
        company.StockPrice_D_3,
        company.StockPrice_D_4,
        company.StockPrice_D_5,
    ]
    company_data["PriceHistoric"] = price_historic
    company_data["SentimentScores"] = get_company_article_sentiment_scores(
        company.CompanyID,
    )
    return company_data


def set_all_companies_predicted_price() -> None:
    """Sets the predicted_stock_price of all companies by running their data through the linear regression model
    to be called after the articles have been fetched.
    """
    try:
        companies = db.session.execute(db.select(Company)).scalars().all()
        for company in companies:
            try:
                predicted_stock_price = TTLinearRegression(
                    company.StockSymbol,
                    get_company_article_sentiment_scores(company.CompanyID),
                    [
                        company.StockPrice_D_1,
                        company.StockPrice_D_2,
                        company.StockPrice_D_3,
                        company.StockPrice_D_4,
                        company.StockPrice_D_5,
                    ],
                ).calculate_stock_price()
                print(
                    "predicted stock price for ",
                    company.CompanyName,
                    " is: ",
                    predicted_stock_price,
                )
                db.session.execute(
                    update(Company)
                    .where(Company.CompanyID == company.CompanyID)
                    .values(PredictedStockPrice=predicted_stock_price),
                )
                db.session.commit()
            except SQLAlchemyError as e:
                # Handle exceptions appropriately
                print(
                    f"An error occurred in processing company with ID {company.CompanyID}: {e}",
                )
    except SQLAlchemyError as ex:
        # Handle exceptions appropriately
        print(f"An error occurred while retrieving companies: {ex}")


def update_all_companies_daily() -> bool:
    """Updates daily stock prices for all companies."""
    try:
        companies = Company.query.all()
        for company in companies:
            company_daily_update(company)
        logging.info("Daily updates for all companies completed successfully.")
    except SQLAlchemyError:
        logging.exception("Error updating daily stock prices")
        db.session.rollback()  # Rollback changes in case of an error
        return False
    return True


def get_articles_from_news_api() -> None:
    """Calls the News Api script with the names of the companies and retrieves articles
    test with names.
    """
    company_names = [
        "3i",
        "Admiral Group",
        "Airtel Africa",
        "Anglo American",
        "Antofagasta",
        "Ashtead Group",
        "Associated British Foods",
        "AstraZeneca",
        "Auto Trader Group",
        "Aviva plc",
        "B&M",
        "BAE Systems",
        "Barclays",
        "Barratt Developments",
        "Beazley",
        "Berkeley Group",
        "BP",
        "British American Tobacco",
        "BT Group",
        "Bunzl",
        "Burberry",
        "Centrica",
        "Coca-Cola",
        "Compass Group",
        "Convatec",
        "Croda International",
        "DCC",
        "Diageo",
        "Diploma",
        "Endeavour Mining",
    ]
    others = [
        "Entain",
        "Experian",
        "F&C Investment”",
        "Flutter Entertainment",
        "Frasers Group",
        "Fresnillo",
        "Glencore",
        "GSK",
        "Haleon",
        "Halma",
        "Hikma Pharmaceuticals",
        "Howdens Joinery",
        "HSBC",
        "InterContinental Hotels",
        "IMI",
        "Imperial Brands",
        "Informa",
        "Intermediate Capital",
        "International Airlines Group",
        "Intertek",
        "JD Sports",
        "Kingfisher",
        "Land Securities",
        "Legal & General",
        "Lloyds Banking Group",
        "London Stock Exchange",
        "M&G plc",
        "Marks and Spencer",
        "Melrose Industries",
        "Mondi",
        "National Grid",
        "NatWest",
        "Next plc",
        "Ocado Group",
        "Pearson",
        "Pershing Square Holdings",
        "Persimmon",
        "Phoenix Group",
        "Prudential",
        "Reckitt",
        "RELX",
        "Rentokil Initial",
        "Rightmove",
        "Rio Tinto",
        "Rolls-Royce Holdings",
        "RS Group",
        "Sage Group",
        "Sainsbury",
        "Schroders",
        "Scottish Mortgage",
        "Segro",
        "Severn Trent",
        "Shell",
        "DS Smith",
        "Smiths Group",
        "Smith & Nephew",
        "Smurfit Kappa",
        "Spirax-Sarco Engineering",
        "SSE",
        "Standard Chartered",
        "St. James Place",
        "Taylor Wimpey",
        "Tesco",
        "Unilever",
        "United Utilities",
        "Unite Group",
        "Vodafone Group",
        "Weir Group",
        "Whitbread",
        "WPP",
    ]

    get_news = extract_news_script.GetNewsClass(company_names)
    articles_dict = get_news.fetch_all_articles()

    for article in articles_dict:
        article_id = get_article_from_news_script(article)
        """
        if the article is notification-worthy, we create and broadcast the notification
        """
        if (
            article["PredictionScore"] > HIGHLY_POSITIVE_SCORE
            or article["PredictionScore"] < HIGHLY_NEGATIVE_SCORE
        ):
            company_name = article["Company"]
            company = (
                db.session.execute(
                    db.select(Company).filter(
                        Company.CompanyName.like(f'%{article["Company"]}%'),
                    ),
                )
                .scalars()
                .first()
            )
            company_id = company.CompanyID
            notification_content = "New notification for " + company_name
            new_notification = Notification(article_id, notification_content)
            db.session.add(new_notification)
            db.session.commit()
            insert_user_notification_read_objects(new_notification, company_id)


def get_company_followers(company_id: int) -> list:
    """Given a company_id, returns all the user_id of users following that company."""
    return (
        db.session.execute(
            db.select(Follow.UserID).filter(Follow.CompanyID == company_id),
        )
        .scalars()
        .all()
    )


def insert_user_notification_read_objects(
    notification: Notification,
    company_id: int,
) -> None:
    """Given a new notification and the related company_id, creates individual UNR
    objects for users following that company.
    """
    user_ids = get_company_followers(company_id)
    user_notification_read_list = [
        UserNotificationRead(user_id, notification.NotificationIDa)
        for user_id in user_ids
    ]
    db.session.add_all(user_notification_read_list)
    db.session.commit()


def get_recommendation_system_info(user_id: int) -> dict:
    """Returns the information needed for the recommendation system."""
    # Get the CompanyIDs the user is following
    followed_companies = set(
        db.session.execute(
            db.select(Follow.CompanyID).filter(Follow.UserID == user_id),
        )
        .scalars()
        .all(),
    )

    # Get all companies
    all_companies = db.session.execute(db.select(Company)).scalars().all()

    following_companies = []
    non_following_companies = []
    keywords = []

    for company in all_companies:
        company_dict = {
            "CompanyID": company.CompanyID,
            "CompanyName": company.CompanyName,
            "Industry": company.Industry,
        }

        if company.CompanyID in followed_companies:
            following_companies.append(company_dict)
            # keywords for followed companies
            company_keywords = (
                db.session.execute(
                    db.select(Article.KeyWords).filter(
                        Article.CompanyID == company.CompanyID,
                    ),
                )
                .scalars()
                .all()
            )
            keywords.extend(company_keywords)  # Add keywords to the list
        else:
            non_following_companies.append(company_dict)

    return {
        "following": following_companies,
        "non_following": non_following_companies,
        "keywords": list(set(keywords)),  # Remove duplicates and convert to list
    }
